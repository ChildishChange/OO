readme：
1.程序开始运行时，要求输入地图文件正确的绝对路径，要求地图为.txt文件，压缩包里附带了自己的测试地图文件，文件如果超过八十行，每行不足或超过八十个数字都会报错，数字之间不能有空格，最后一行末尾不能有回车或换行符，每一行的数字之间不能用空格或制表符隔开，且地图的尺寸要满足指导书中的要求，不可缺少数字。。。生成的地图如下
原点--Y轴--->
|
|
X轴
|
↓
2.正确输入地图后，程序会读取.txt文件，并将其转化为邻接矩阵，这一步为测试者不可见
3.主线程会创建100个出租车线程，并运行，且会在控制台上打印所有出租车的初始位置，出租车编号为0-99
4.如要添加指令，请按照HolyCrapTest.java中的示范格式：
		Order a = new Order(0,0,79,79);
		Orders.add(a);
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		线程暂停为非必选项，另外Order实例变量的名称不能相同。。不能使用while（true）循环添加代码
5.如要获取出租车所在位置和状态，让线程暂停相应的时间后，添加如下代码：
	System.out.println("第"+i+"号出租车目前状态为："+Taxis[i].getstate()+",处于("+Taxis[i].getPositionX()+","+Taxis[i].getPositionY()+")位置。");
6.输出示例：
	这两条指令未被响应：
	从(0,0)到(79,79)的订单长时间无响应，订单取消
	从(55,60)到(15,30)的订单长时间无响应，订单取消
	若被响应：
	第97号出租车抢单：从(0,0)到(79,79)
	第97号出租车抢到从(0,0)到(79,79)的单。
	从(55,60)到(15,30)的订单长时间无响应，订单取消
	97号出租车到达:(0,0)位置。
	97号出租车准备前往:(79,79)位置。
	97号出租车到达:(79,79)位置。
如果想要检测出租车的路径是否是最短路径，可在Taxi.java中，将gotoPosition1方法中的system.out.println取消注释。
7.关于最短路径算法：本程序使用广度优先搜索进行最短路径搜索。在通过所给的80×80地图构造邻接矩阵时，由于每个点只与四个特定的点有可能有联系，所以邻接矩阵是一个稀疏矩阵，但我仍然使用了6400×6400的二维数组，这一点浪费了很多内存，下一步优化可能使用一维数组映射二维数组。另外，与其他一些同学的设计不同，其他同学的设计是在构造完邻接矩阵后就将地图上任意两点间的最短路径计算出来并保存，而本人的设计是即用即算。

8.关于红绿灯，一切按照指导书


关于本次作业的更新内容：
所有都在HolyCrapTest.java的run方法中有示例
关闭道路：map.closeRoad(77,79,1);
打开道路：map.openRoad(77, 79, 1);
查看某条路的流量：System.out.println("flow:"+map.getFlow(25, 25, 1));

这三个函数有一个共同特点，即三个变量的含义
第一个变量是道路左端点或上端点在DigitalMap中的X坐标值
第二个变量是道路左端点或上端点在DigitalMap中的Y坐标值
第三个变量可为0或为1，为0则代表横向道路，为1则代表竖向道路，其余值会报错


以下是一次示例运行输出：

