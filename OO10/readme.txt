readme：
0.因为是直接在第八次作业基础上改的。。所以项目名没有改。。
1.程序开始运行时，要求输入地图文件正确的绝对路径，要求地图为.txt文件，压缩包里附带了自己的测试地图文件，文件如果超过八十行，每行不足或超过八十个数字都会报错，数字之间不能有空格，最后一行末尾不能有回车或换行符，每一行的数字之间不能用空格或制表符隔开，且地图的尺寸要满足指导书中的要求，不可缺少数字。。。生成的地图如下
原点--Y轴--->
|
|
X轴
|
↓
xy的范围是[0到79]的整数
2.正确输入地图后，程序会读取.txt文件，并将其转化为邻接矩阵，这一步为测试者不可见
3.主线程会创建100个出租车线程，并运行，且会在控制台上打印所有出租车的初始位置，出租车编号为0-99
4.如要添加指令，请按照HolyCrapTest.java中的示范格式：
		Order a = new Order(79,79,rand.nextInt(80),rand.nextInt(80));
		if(a.getSuccess()==true)
			Orders.add(a);
		//if语句中是必要项目，不得省去，否则不能将这条指令添加进队列
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		不能使用while（true）循环添加代码
		
5.如要获取出租车所在位置和状态，让线程暂停相应的时间后，添加如下代码：
	System.out.println("第"+i+"号出租车目前状态为："+Taxis[i].getstate()+",处于("+Taxis[i].getPositionX()+","+Taxis[i].getPositionY()+")位置。");
6.输出示例：
	这两条指令未被响应：
	从(0,0)到(79,79)的订单长时间无响应，订单取消
	从(55,60)到(15,30)的订单长时间无响应，订单取消
	若被响应：
	第97号出租车抢单：从(0,0)到(79,79)
	第97号出租车抢到从(0,0)到(79,79)的单。
	从(55,60)到(15,30)的订单长时间无响应，订单取消
	97号出租车到达:(0,0)位置。
	97号出租车准备前往:(79,79)位置。
	97号出租车到达:(79,79)位置。
如果想要检测出租车的路径是否是最短路径，可在Taxi.java中，将gotoPosition1方法中的system.out.println取消注释。
7.关于最短路径算法：本程序使用广度优先搜索进行最短路径搜索。在通过所给的80×80地图构造邻接矩阵时，由于每个点只与四个特定的点有可能有联系，所以邻接矩阵是一个稀疏矩阵，但我仍然使用了6400×6400的二维数组，这一点浪费了很多内存，下一步优化可能使用一维数组映射二维数组。另外，与其他一些同学的设计不同，其他同学的设计是在构造完邻接矩阵后就将地图上任意两点间的最短路径计算出来并保存，而本人的设计是即用即算。

8.关于红绿灯，一切按照指导书


关于本次作业的更新内容：
所有都在HolyCrapTest.java的run方法中有示例
关闭道路：map.closeRoad(77,79,1);
打开道路：map.openRoad(77, 79, 1);
查看某条路的流量：System.out.println("flow:"+map.getFlow(25, 25, 1));

这三个函数有一个共同特点，即三个变量的含义
第一个变量是道路左端点或上端点在DigitalMap中的X坐标值
第二个变量是道路左端点或上端点在DigitalMap中的Y坐标值
第三个变量可为0或为1，为0则代表横向道路，为1则代表竖向道路，其余值会报错

关于本次作业更新内容：
迭代器:在测试线程中有样例，如果在获取迭代器时，还有某辆车没有完成当前指令，那么不会输出这次接客的路径移动，另外迭代器是使用的自带的，能力有限不能完成，而且PPT里没有要求。。所以应该是没有问题的。。
高级出租车:这次将两个出租车类移到了另一个包，保证了安全性


关于上次作业BUG情况：
一些规格有问题
一些overview写在文档里了没有写到代码里
可以把不满足要求的指令添加进队列

祝安好！最后一次代码作业了，好开心！
